//Examples run from reference manual 10/04/2018

//'variable' keyword missing
define datapoint ruleset dpr1 (flow, obs_value) is
when flow="CREDIT" or flow="DEBIT" then obs_value >=0 errorcode "bad value"
end datapoint ruleset;

//parenthesis in errorcode
define datapoint ruleset dpr1 (variable flow, obs_value) is
when flow="CREDIT" or flow="DEBIT" then obs_value >=0 errorcode ("bad value")
end datapoint ruleset;

//'is' keyword is missing after signature
define datapoint ruleset DPR_1 ( valuedomain flow_type as A, numeric_value as B )
when A = "CREDIT" or A = "DEBIT" then B >= 0 errorcode "Bad value" errorlevel 10
end datapoint ruleset;

//'when' keyword is missing
define datapoint ruleset DPR_2 ( variable flow as F, obs_value as O) is
F = "CREDIT" or F = "DEBIT" then O >= 0 errorcode "Bad value"
end datapoint ruleset;

//'rule' keyword missing in signature
define hierarchical ruleset BeneluxCountriesHierearchy (valuedomain Geo_Area) is
BENELUX = BELGIUM + LUXEMBOURG + NETHERLANDS
end hierarchical ruleset;

//'ruleset' keyword missing at the end
define hierarchical ruleset BeneluxRuleset (valuedomain rule GeoArea) is
Belgium = Belgium
;Luxembourg = Luxembourg
;Netherlands = Netherlands
;Benelux = Belgium + Luxembourg + Netherlands
end hierarchical;

//'hierarchical' keyword missing from define
define ruleset CalcCountryLevel (valuedomain condition Residence rule GeoArea) is
when Residence = "resident" then Country1 = Country1
; when Residence = "non-resident" then Country1 = Region11+Region1M        
; when Residence = "resident" then CountryN = CountryN
; when Residence = "non-resident" then CountryN = RegionN1 + RegionNM
end hierarchical ruleset;

//second part missing from hierarchy (should be male + female)
define hierarchical ruleset sex_hr (valuedomain rule sex) is
TOTAL = MALE + 
end hierarchical ruleset;

//'valuedomain' keyword missing form signature
define hierarchical ruleset BeneluxCountriesHierarchy (rule GeoArea) is
BENELUX = BELGIUM + LUXEMBOURG + NETHERLANDS errorcode "Bad value for Benelux" 
end hierarchical ruleset;

//wrong keyword used in signature 'variables'
define hierarchical ruleset american_partners_hr (variables rule PartnerArea) is
NORTH_AMERICA > US ;
SOUTH_AMERICA = BR + UY + AR + CL 
end hierarchical ruleset;

//operator name starts with symbol
define operator _max1 (x integer, y integer)
returns boolean is 
if x > y then x else y
end operator;

//second parameter missing type
define operator max1 (x integer, y)
returns boolean is 
if x > y then x else y
end operator;

//'returns' keyword missing
define operator add (x integer default 0, y integer default 0)
number is 
x+y
end operator;

//body is missing
define operator add (x integer default 0, y integer default 0)
returns number is 
end operator;

//right parenthesis missing
( DS_1  +  DS_2 

//left parenthesis missing
CMP_1  -  CMP_2 )

//third operand is missing
( DS_2   -   3   * )

//unmatched parethesis at the end
(DS_1 + DS_2) * DS_3 (

//consecutive signs --
(CMP_1 -- CMP_2/(CMP_3+CMP_4))*CMP_5

//persistent assignment used twice in a row
DS_r <- <- DS_1

//'=' placed after persistent assignment
DS_r <- = DS_1 - DS_2

//two identifiers in a row
DS_r := DS_1 DS_2

//empty assignment
DS_r := 

//left operand missing
:= DS_1 - DS_2

//last identifier starts with a numeric character
DS_r := 3 + 22d

//membership used two times in a row
DS_r  := DS_1#Me_1#Me_2

//component missing
DS_r  := DS_1# 

//dataset name missing
DS_r  := #At_1

//unmatched parenthesis
max1 ( 2, 3 

//arguments not separated by comma
max1 ( 2 3 id)

//'returns' keyword is missing
DS_r := eval( SQL3( DS_1 ) integer)

//1st mandatory operator is missing
ds2 := ds1[calc m2 := cast(number, "DD.DDD")+2]

//2nd mandatory operator is missing
ds2 := ds1[calc m2 := cast(m1,"YYYY-MM-DD")]

//both mandatory operators missing
ds2 := ds1[calc m2 := cast("YYYY-MM-DD")]

//no operators in cast
ds2 := ds1[calc m2 := length(cast())]

//incorrect use of keyword 'inner_join'
innerjoin ( ds1 as d1, ds2 as d2 using Id1, Id2 filter d1#Me1 + d2#Me1 <10
apply d1 / d2
keep Me1, Me2, Me3
rename Id1 to Id10, id2 to id20
)

//comma placed before using
inner_join ( ds1 as d1, ds2 as d2, using Id1, Id2 filter d1#Me1 + d2#Me1 <10
apply d1 / d2
keep Me1, Me2, Me3
rename Id1 to Id10, id2 to id20
)

//apply and calc used on the same statement
inner_join ( ds1 as d1, ds2 as d2 using Id1, Id2 filter d1#Me1 + d2#Me1 <10
apply d1 / d2
calc Me1 := d1#Me1 + d2#Me3
keep Me1, Me2, Me3
rename Id1 to Id10, id2 to id20
)

//keep and drop used on the same statement
inner_join ( ds1 as d1, ds2 as d2 using Id1, Id2 filter d1#Me1 + d2#Me1 <10
apply d1 / d2
keep Me1, Me2, Me3
drop Me4
rename Id1 to Id10, id2 to id20
)

//rename used without 'to'
left_join ( ds1 as d1, ds2 as d2
filter d1#Me1 + d2#Me1 <10,
calc Me1 := d1#Me1 + d2#Me3, keep Me1
rename Id1 , Me1 
)

//'having' expression in parenthesis 
full_join (ds1 as d1, ds2 as d2
filter d1#Me1 + d2#Me1 <10,
aggr Me1:= sum(Me1), attribute At20:=avg(Me2)
group by Id1, Id2
having (sum(Me3)>0)
)

//expression is used in grouping clause instead of component list
full_join (ds1 as d1, ds2 as d2
filter d1#Me1 + d2#Me1 <10,
aggr Me1:= sum(Me1), attribute At20:=avg(Me2)
group by Id1>2
having (sum(Me3)>0)
)

//parenthesis mismatch
DS_r := inner_join ( DS_1 as d1, DS_2 as d2, keep Me_1, d2#Me_2, Me_1A

//no use of parenthesis
DS_r := left_join DS_1 as d1, DS_2 as d2, keep Me_1, d2#Me_2, Me_1A

//no comma used before 'rename'
DS_r := cross_join (DS_1 as d1, DS_2 as d2
rename d1#Id_1 to Id11, d1#Id_2 to Id12, d2#Id1 to Id21, d2#Id2 to Id22, d1#Me_2 to Me12 )

//no operands after join keyword
DS_r := inner_join (filter Me_1 ="A",
calc Me_4 = Me_1||Me_1A, drop d1#Me_2)

//number used instead of string or component
"Hello" || 5

//second operand missing
ds_1 || 


//first operand missing
DS_r :=  || DS_2

//space used between '||'
DS_r := DS_1[calc Me_2:= Me_1 | | "world"]

//number used instead of string or component
trim(65)

//more than one operands used
DS_r := rtrim(DS_1, DS_2)

//no operands used
trim()

//number used instead of string or component
upper(345)

//more than one operands used
lower(ds_1, ds_2)

//no operands used
DS_r := upper()

//no operands used
substr ()

//more than 3 operands used
substr (DS_1, 2, 3, 5)

//wrong type of third operand
substr ( DS_1, 2, "abc" )

//first operand ignored
substr (_, 2, 3)

//all operands ignored
substr ( _, _ , _ )

//wrong type of first operand
substr (123, 1, 2)

//negative number used
DS_r:= substr ( DS_1 , 7, -1 )

//second operand is 0
DS_r:= substr ( DS_1 , 0 , 5 )

//no operands used
replace()

//more than 3 operands used
replace(DS_1, "Hello", "Hi", "hi")

//wrong type of second operand
replace(DS_1, 2, "Hello")

//second operand ignored
replace("Hello world", _ , "Hi")

//second operand missing
replace("Hello world", , "Hello")

//only one operand used
replace ("Hello")

//no operands used
instr()

//more operands used
instr(DS_1, "ab", 2, 3, 4)

//first operand ignored
instr(_, "ab", 2, 3)

//first and second operands ignored
instr(_, _, 2,3)

//all operands ignored
instr(_, _, _, _)

//wrong type of third operand
instr(DS_1, "ab","hi",2)

//wrong type of second operand
instr(DS_1, 2, 1, 4)

//wrong value of third operand
DS_r:= instr(ds_1,"hello", 0)

//no operand used
length()

//more than one operands used
length(DS_1, "hi")

//wrong type of operand used
DS_r := length(123)

//wrong type of operand
DS_r := + "hello"

//wrong type of operand
DS_r := - "name"

//second operand missing
DS_r := DS_1 + 

//wrong type of first operand
DS_r := "hello" + 3

//second operand missing
DS_r := DS_1 - 

//wrong type of second operand
DS_r := DS_1 - "id"

//first operand missing
DS_r :=  * DS_2

//wrong typy of second operand
DS_r := -3 * "name"

//second operand missing
DS_r := DS_1 /

//wrong type of first operand
DS_r := "hi" / 10

//no operands used
DS_r := mod ()

//only one operand used
DS_r := mod ( DS_1)

//wrong type of first operand
DS_r := mod ( "hi", 15 )

//more than two operands used
DS_r := mod ( DS_1, DS_2, DS_3 )

//no operands used
DS_r := round()

//first operand ignored
DS_r := round(_, 2)

//more than two operands used
DS_r := round(DS_1, 0, 3)

//wrong type of first operand
DS_r := DS_1 [ calc Me_10:= round("hello")]

//wrong type of second operand
DS_r := DS_1 [ calc Me_20:= round( Me_1 , "abc" ) ]

//both operands ignored
round(_,_)

//no operands used
DS_r := trunc()

//first operand ignored
DS_r := trunc(_, 0)

//more than two operands used
DS_r := trunc(DS_1, 0, 3)

//wrong type of first operand
DS_r := DS_1[ calc Me_10:= trunc("hello") ]

//wrong type of second operand
DS_r := DS_1[ calc Me_20:= trunc( Me_1 , "abc" ) ]

//both operands ignored
DS_r := trunc(_, _)

//no operands used
DS_r := ceil ()

//more than one operands used
DS_r := ceil (DS_1,2,3)

//wrong type of operand
DS_r := ceil ("abc")

//no operands used
DS_r := floor ()

//more than one operands used
DS_r := floor ( DS_1,2)

//wrong type of operand
DS_r := floor ( "abc" )

//no operands used
DS_r := abs ()

//more than one operands used
DS_r := abs (DS_1, DS_2)

//wrong type of operand
DS_r := DS_1 [ Me_10 := abs("hello") ]

//no operands used
DS_r := exp()

//more than one operands used
DS_r := exp(DS_1, DS_2)

//wrong type of operand
DS_r := DS_1 [ Me_1 := exp ( "hello") ]

//no operands used
DS_r := ln()

//more than one operands used
DS_r := ln(DS_1, DS_2)

//wrong type of operand
DS_r := DS_1 [ Me_2 := ln ( "hello" )]

//wrong value used
DS_r := ln(-23)

//no operands used
DS_r := power()

//more than two operands used
DS_r := power(DS_1, 2, 3)

//wrong type of second operand
DS_r := DS_1[ calc Me_1 := power(Me_1, Me_2) ]

//no operands used
DS_r := log ()

//more than two operands used
DS_r := log ( DS_1, 2, 3 )

//wrong type of second operand
DS_r := log ( DS_1, "abc" )

//wrong value of second operand
DS_r := DS_1 [ calc Me_1 := log (Me_1, 0) ]

//wrong value of first operand
DS_r := log ( -3, 2 )

//no operand used
DS_r := sqrt()

//more than one operands used
DS_r := sqrt(DS_1, DS_2)

//wrong type of operand
DS_r := sqrt("hello")

//wrong value of operand
DS_r := DS_1 [ calc Me_1 := sqrt ( -1 ) ]

//first operand missing
DS_r := = 0.08

//second operand missing
DS_r := DS_1 [ calc Me_2 := Me_1 = ]

//first operand missing
DS_r :=  <> DS_2

//second operand missing
DS_r := DS_1 [ Me_2 := Me_1<>]

//first operand missing
DS_r :=  > 20

//second operand missing
DS_r := DS_1 [ Me_2 := Me_1 >  ]

//first operand missing
DS_r :=  < 15000000

//second operand missing
DS_r := DS_1 < 

//no operands used
DS_r:= between()

//more than three operands used
DS_r:= between(ds1, 5,10, 3)

//less than three operands used
DS_r:= between(ds1, 5)

//no use of '{' '}'
ds := ds_2 in 1,4,6

//parenthesis used
ds := ds_2 in (1,4,6)

//wrong type of collection
DS_r := DS_1#Id_2 in "myGeoValueDomain"

//operand is missing
ds :=  in myValueDomain

//collection is missing
DS_r := DS_1 [ calc Me_2:= Me_1 in {}]

//wrong type of collection
"a" in 123

//no operands used
match_characters()

//more than two operands used
match_characters(ds1, "[abc]+\d\d", "abc")

//first operand missing
ds1 [ calc m1 := match_characters("[abc]+\d\d")]

//wrong type of regex
match_characters(ds1, ds2)

//wrong type of first operand
match_characters(123, "[abc]+\d\d")

//no operand used
isnull()

//more than one operand used
isnull(NULL, "hello")

//wrong type of operand
DS_r := DS_1[ Me_2 := is_null(123) ]

//no operands used

//more than three operands used

//second operand missing

//
exists_in ( DS_1, DS_2, true )

exists_in ( DS_1, DS_2 )

exists_in ( DS_1, DS_2, all )

DS_r := exists_in (DS_1, DS_2, all)

DS_r := exists_in (DS_1, DS_2, true)

DS_r := exists_in (DS_1, DS_2, false)

DS_r:= DS_1 and DS_2

DS_r := DS_1 [ Me_2:= Me_1 and true ]

DS_r:= DS_1 or DS_2

DS_r:= DS_1 [ Me_2:= Me_1 or true ]

DS_r:=DS_1 xor DS_2

DS_r:= DS_1 [ Me_2:= Me_1 xor true ]

DS_r:= not DS_1

DS_r:= DS_1 [ calc Me_2 := not Me_1 ]

DS_r := period_indicator ( DS_1 )

DS_r := DS_1 [ filter period_indicator ( Id_3 ) = "a"]

DS_r := fill_time_series ( DS_1, single )

DS_r := fill_time_series ( DS_1, all )

DS_r := fill_time_series ( DS_2, single )

DS_r := fill_time_series ( DS_2, all )

DS_r := fill_time_series ( DS_3, single )

DS_r := fill_time_series ( DS_3, all )

DS_r := fill_time_series ( DS_4, single )

DS_r := fill_time_series ( DS_4, all )

DS_r := flow_to_stock ( DS_1 )

DS_r := flow_to_stock ( DS_2 )

DS_r := flow_to_stock ( DS_3 )

DS_r := stock_to_flow ( DS_1 )

DS_r := stock_to_flow ( DS_2 )

DS_r := stock_to_flow ( DS_3 )

DS_r := stock_to_flow ( DS_4 )

/*The following examples are modified to include the correct operator name timeshift in order 
to run (lines 4813, 4821, 4829, 4837) */
DS_r := timeshift(DS_1, -1)

DS_r := timeshift(DS_2, 2)

DS_r := timeshift(DS_3,1)

DS_r := timeshift(DS_3, -1)

//The following example is modified in order to match the time_agg syntax (line 4854)
sum ( DS group all time_agg ("A", Me)) 

time_agg("A",cast("2012Q1", time_period, "YYYY\Qq"))

time_agg("M", cast("2012-12-23",date,"YYYY-MM-DD"))

time_agg("M", DS1)

ds_2 := ds1[calc Me1 := time_agg("M",Me1)]

DS_r := sum ( DS_1 ) group all time_agg ( "A",_,Me_1)

//The following example is modified to remove a space inside keyword time_agg (line 4909)
DS_r := time_agg ("Q", cast("2012M01",time_period, "YYYY\MMM"))

/*The following two examples need to be modified in order to match the syntax definition (lines 4915, 4921)
time_agg( “Q”, cast(“20120213”, date, ”YYYYMMDD”), _ , false )
time_agg(cast( ”A”, “2012M1”, date, ”YYYYMMDD”), _, true ) */

//The following example is modified to include the parenthesis after the current_date operator in order to run (line 4952)
cast(current_date(), string, "YYYY.MM.DD")

DS_r := union(DS_1,DS_2)

DS_r := intersect(DS_1,DS_2)

DS_r := setdiff ( DS_1, DS_2 )

DS_r := symdiff ( DS_1, DS_2 )

DS_r := hierarchy ( DS_1, HR_1 rule Id_2 non_null )

DS_r := hierarchy ( DS_1, HR_1 rule Id_2 non_zero )

DS_r := hierarchy ( DS_1, HR_1 rule Id_2 partial_null )

avg(DS_1)

avg ( DS_1 group by Id_1, Id_2 )

avg ( DS_1 group except Id_1, Id_2 )

avg ( DS_1 group all time_agg ("Q"))

DS_r := avg ( DS_1 group by Id_1 )

DS_r := avg ( DS_1 group except Id_2, Id_3 )

DS_r := avg ( DS_1#Me_1 group by Id_1 )

DS_r := sum ( DS_1 group by Id_1, Id_3 )

DS_r := avg ( DS_1 )

DS_r := DS_1 [ aggr Me_2 := max ( Me_1 ) , Me_3 := min ( Me_1 ) group by Id_1 ]

sum ( DS_1 over ( partition by Id_1 order by Id_2 ) )

sum ( DS_1 over ( order by Id_2 ) )

avg ( DS_1 over ( order by Id_1 data points between 1 preceding and 1 following ) )

DS_1 [ calc M1 := sum ( Me_1 over ( order by Id_1 ) ) ]

DS_r := sum ( DS_1 over ( order by Id_1, Id_2, Id_3 data points between 1 preceding and 1 following ) )

DS_r := count ( DS_1 group by Id_1 )

DS_r := sum ( DS_1 group by Id_1 having count() > 2 )

DS_r := min ( DS_1 group by Id_1 )

DS_r := max ( DS_1 group by Id_1 )

DS_r := median ( DS_1 group by Id_1 )

DS_r := sum ( DS_1 group by Id_1 )

DS_r := avg ( DS_1 group by Id_1 )

DS_r := stddev_pop ( DS_1 group by Id_1 )

DS_r := stddev_samp ( DS_1 group by Id_1 )

DS_r := var_pop ( DS_1 group by Id_1 )

//In the following example '[' and ']' were removed in order to run (line 6011)
DS_r := var_samp ( DS_1 group by Id_1)

DS_r := first_value ( DS_1 over ( partition by Id_1, Id_2 order by Id_3 data points between 1 preceding and 1 following))

DS_r := last_value ( DS_1 over ( partition by Id_1, Id_2 order by Id_3 data points between 1 preceding and 1 following))

DS_r := lag ( DS_1 , 1 over ( partition by Id_1 , Id_2 order by Id_3 ) )

DS_r := lead ( DS_1 , 1 over ( partition by Id_1 , Id_2 order by Id_3 ) )

//The following example was modified in order to add the required operand before 'over' (line 6252)
DS_r := DS_1 [ calc Me2 := rank (DS_1, over ( partition by Id_1 , Id_2 order by Me_1 ) )]

DS_r := ratio_to_report ( DS_1 over ( partition by Id_1, Id_2 ) )

//The following two examples were modified to add the required keyword 'output' (lines 6321, 6322)
check_datapoint ( DS1, DPR output invalid)

check_datapoint ( DS1, DPR output all_measures)

DS_r := check_datapoint ( DS_1, dpr1 )

//The following example was modified to add the required keyword 'output' (line 6373)
DS_r := check_datapoint ( DS_1, dpr1 output all)

check_hierarchy ( DS1, HR_2 non_null dataset invalid )

check_hierarchy ( DS1, HR_3 non_zero dataset_priority all )

DS_r := check_hierarchy ( DS_1, HR_1 rule Id_2 partial_null all )

//The following example is modified to place errorcode and errormessage in quotes (line 6572)
check ( DS1 > DS2 errorcode "myerrorcode" errorlevel "myerrorlevel" imbalance DS1 - DS2 invalid )

DS_r := check ( DS1 >= DS2 imbalance DS1 - DS2 )

if x1 > x2 then 2 else 5

DS_r := if ( DS_cond#Id_4 = "F" ) then DS_1 else DS_2

nvl ( ds1#m1, 0 )

nvl ( 5, 0 )

nvl ( null, 0 )

DS_r := nvl ( DS_1, 0 )

DS_1 [ filter Me_3 > 0 ]

DS_1 [ filter Me_3 + Me_2 <= 0 ]

DS_r := DS_1 [ filter Id_1 = 1 and Me_1 < 10 ]

DS_1 [ calc Me_3 := Me_1 + Me_2 ]

DS_r := DS_1 [ calc Me_1:= Me_1 * 2 ]

DS_r := DS_1 [ calc attribute At_1:= "EP"]

DS_1 [ aggr M1 := min ( Me_1 ) group by Id_1, Id_2 ]

DS_1 [ aggr M1 := min ( Me_1 ) group except Id_1, Id_2 ]

DS_r := DS_1 [ aggr Me_1:= sum( Me_1 ) group by Id_1 , Id_2 ]

DS_r := DS_1 [ aggr Me_3:= min( Me_1 ) group except Id_3 ]

DS_r := DS_1 [ aggr Me_1:= sum( Me_1 ), Me_2 := max( Me_1) group by Id_1 , Id_2
having mean (Me_1 ) > 2 ]

DS_1 [ keep Me_2, Me_3 ]

DS_r := DS_1 [ keep Me_1 ]

DS_1 [ drop Me_2, Me_3 ]

DS_r := DS_1 [ drop At_1 ]

DS_1 [ rename Me_2 to Me_3 ]

DS_r := DS_1 [ rename Me_1 to Me_2, At_1 to At_2]

DS_1 [ pivot Id_2, Me_1 ]

DS_r := Ds_1 [ pivot Id_2, Me_1 ]

DS [ unpivot Id_5, Me_3 ]

DS_r := DS_1 [ unpivot Id_2, Me_1]

//The following example was modified to add the operator 'sub' in order to run (line 7201)
DS_r := DS_1 [sub Id_2 = "A", Id_5 = 1 ]

DS_r := DS_1 [ sub Id_1 = 1, Id_2 = "A"]

DS_r := DS_1 [ sub Id_1 = 1, Id_2 = "B", Id_3 = "YY"]

DS_r := DS_1 [sub Id_2 ="A"] + DS_1 [sub Id_2 ="B"]
















