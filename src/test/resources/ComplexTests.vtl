// Need to add space before number being extracted, because they are considered as one token otherwise (e.g. -1 is a token and not the extraction of 1)
CurTable:= substr(InputFile, instr(InputFile, "_", 1, 1) + 1, instr(InputFile, "_", 1, 2) - instr(InputFile, "_", 1, 1) - 1);

CurFreq:= substr(InputFile, instr(InputFile, "_", 1, 2) + 1, instr(InputFile, "_", 1, 3) - instr(InputFile, "_", 1, 2) - 1);

CurCountry:= substr(InputFile, instr(InputFile, "_", 1, 3) + 1, instr(InputFile, "_", 1, 4) - instr(InputFile, "_", 1, 3) - 1);

// 1.1 and 1.2: wrong envelope: check that the dataset contains the table, freq and country indicated in the file name
//errorcode is modified to be a unified string constant instead of a series of concat expressions
WrongEnvelop:=check ( na_main#table_identifier=CurTable and na_main#freq=CurFreq and na_main#ref_area=CurCountry 
	errorcode "Bad table_identifier, frequency or ref_area:  || CurTable ||  || CurFreq ||  || CurCountry"
	errorlevel "Error" invalid ) [ drop bool_var ] [calc identifier ruleid := "FIL" ] [calc obs_value := null ] [calc imbalance1 := null ] ;

// 1.3 and 1.4: logical checks
//imbalance cannot be used as is because it's a keyword. imbalance1 is used instead
LogicalChecks := check_datapoint ( na_main, logical_checks ) [ calc imbalance1 := null ]  ;

// 3.1.1: unexpected series have been found
//imbalance cannot be used as is because it's a keyword. imbalance1 is used instead
ExtraSeries := check ( exists_in ( na_main, derog_na_main ) errorcode "Extra series for table - country" errorlevel "Error" invalid ) [ drop bool_var ] [ calc identifier ruleid := "EXT" ] [ calc obs_value := null ] [ calc imbalance1 := null ] ;

// 3.1.1: missing mandatory series (error)
// we can use inner_join because the series are included in derog_na_main (otherwise collected in ExtraSeries)
//imbalance cannot be used as is because it's a keyword. imbalance1 is used instead
TempMandatory := inner_join ( na_main as a, derog_na_main as b 
	filter b#compliance = "M" and ( isnull (b#derog_1_sy1) or between ( time, b#derog_1_sy1, b#derog_1_ey1 ) ) 
	drop b#obs_value, b#ref_year_price ) ;

Mandatory := check ( exists_in ( TempMandatory, na_main ) errorcode "Data is Mandatory" errorlevel "Error" invalid ) [ drop bool_var ] [calc identifier ruleid := "MAN" ] [calc obs_value := null ] [calc imbalance1 := null ] ;

// 3.1.1. missing voluntary series (warning)
// we can use inner_join because the series are included in derog_na_main (otherwise collected in ExtraSeries)
//imbalance cannot be used as is because it's a keyword. imbalance1 is used instead
TempVoluntary := inner_join ( na_main as a, derog_na_main as b 
	filter b#compliance = "V" and ( isnull (b#derog_1_sy1) or ( time >= b#derog_1_sy1 and time <= b#derog_1_ey1 ) ) 
	drop b#obs_value, b#ref_year_price ) ;
Voluntary:= check ( exists_in ( TempMandatory, na_main ) errorcode "Data is Mandatory" errorlevel "Warning" invalid ) [ drop bool_var ]
[calc identifier ruleid := "VOL" ] [calc obs_value := null ] [calc imbalance1 := null ] ;

// 3.1.2: Incomplete series
//imbalance cannot be used as is because it's a keyword. imbalance1 is used instead
TempCompleted := fill_time_series ( na_main ) ;
Incomplete := check ( exists_in (TempCompleted, na_main ) errorcode "Gap in the time series - annual data" errorlevel "Error" invalid ) [ drop bool_var ] [calc identifier ruleid := "INC" ] [calc obs_value := null ] [calc imbalance1 := null ] ;

// 3.1.3: Zero values and 3.1.4 Negative values combined together
//imbalance, errorlevel and errorcode cannot be used as is because they are keywords. imbalance1, errorlevel1 and errorcode1 are used instead
ZeroNegativeValues := check_datapoint ( na_main, dpr_313_zero_negative_values ) [ keep errorcode1, errorlevel1, obs_value ] [calc imbalance1 := null ] ;

// 4.1.1: Additivity breakdown for sector
//errorlevel cannot be used as is because it's a keyword. errorlevel1 is used instead
AddSector := check_hierarchy ( na_main , hr_sector) [ calc errorlevel1 := "Error" ] ;

// 4.1.2: Outliers (NB: the filter obs_value <> 0 is needed to avoid "division by zero" run-time error)
//ds_prec_value := na_main [calc prec_value := lag ( obs_value , 1 over ( order by time ) ) ] ;
//ds_imbalance := ds_prec_value [ filter prec_value <> 0 ] [ calc diff_perc := abs ( obs_value - prec_value )  / prec_value ] [calc imbalance := abs ( obs_value - prec_value ) ] ;
//ds_invalid := check ( ds_imbalance#diff_perc < 0.03 errorcode "Deviation larger than 3%" errorlevel "Warning" invalid ) ;
//Outliers :=  inner_join ( ds_invalid, ds_imbalance ) [ keep obs_value, imbalance, errorcode, errorlevel ] [calc identifier ruleid := "OUT" ] ; 

// build the output dataset (for the validation report) by assembling together all temporary datasets
// if rule_if is ot unique then raise an error
union ( WrongEnvelop, LogicalChecks, ExtraSeries, Mandatory, Voluntary, Incomplete, ZeroNegativeValues, AddSector, Outliers )
